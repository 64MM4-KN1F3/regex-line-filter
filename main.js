/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RegexLineFilterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var REGEX_HISTORY_LIMIT = 5;
var DEFAULT_SETTINGS = {
  hideEmptyLines: true,
  regexHistory: []
  // Initialize empty history for regex strings
};
var setRegexEffect = import_state.StateEffect.define();
var toggleFilterEffect = import_state.StateEffect.define();
var setHideEmptyLinesEffect = import_state.StateEffect.define();
var filterViewPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.state.field(filterStateField) !== update.startState.field(filterStateField)) {
        this.decorations = this.buildDecorations(update.view);
      }
    }
    // Build decorations - Iterates ALL lines and includes typeof check
    buildDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      const { regex, enabled, hideEmptyLines } = view.state.field(filterStateField);
      if (!enabled || !regex) {
        return builder.finish();
      }
      const doc = view.state.doc;
      try {
        for (let i = 1; i <= doc.lines; i++) {
          const line = doc.line(i);
          const lineText = line == null ? void 0 : line.text;
          if (typeof lineText !== "string") {
            console.warn(`Regex Line Filter: Skipping line ${i} due to non-string text.`);
            continue;
          }
          const isEmpty = lineText.trim().length === 0;
          let shouldHide = false;
          let matchesRegex = regex.test(lineText);
          if (!matchesRegex) {
            shouldHide = true;
          }
          if (hideEmptyLines && isEmpty) {
            shouldHide = true;
          }
          if (shouldHide) {
            builder.add(line.from, line.from, import_view.Decoration.line({
              attributes: { class: "regex-filter-hidden-line" }
            }));
          }
        }
      } catch (e) {
        console.error("Regex Line Filter: Error during decoration build:", e);
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
var filterStateField = import_state.StateField.define({
  create(state) {
    return {
      regex: null,
      enabled: false,
      hideEmptyLines: DEFAULT_SETTINGS.hideEmptyLines
    };
  },
  update(value, tr) {
    let newValue = { ...value };
    for (let effect of tr.effects) {
      if (effect.is(setRegexEffect)) {
        newValue.regex = effect.value;
        newValue.enabled = !!effect.value;
      }
      if (effect.is(toggleFilterEffect)) {
        newValue.enabled = effect.value;
        if (!effect.value) {
          newValue.enabled = false;
        } else if (!newValue.regex) {
          newValue.enabled = false;
          console.warn("Attempted to enable filter without a regex.");
        }
      }
      if (effect.is(setHideEmptyLinesEffect)) {
        newValue.hideEmptyLines = effect.value;
      }
    }
    return newValue;
  }
});
var RegexLineFilterPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.lastRegexStr = null;
    // Stores the most recent successful regex string for pre-filling
    this.cssStyleEl = null;
  }
  async onload() {
    console.log("Loading Regex Line Filter plugin");
    await this.loadSettings();
    this.addCommand({
      id: "toggle-regex-filter",
      name: "Toggle Regex Line Filter",
      editorCallback: (editor, view) => {
        this.toggleFilter(editor, view);
      }
    });
    this.addSettingTab(new RegexLineFilterSettingTab(this.app, this));
    this.registerEditorExtension([filterStateField, filterViewPlugin]);
    this.addCss();
    this.app.workspace.onLayoutReady(() => {
      this.dispatchSettingToEditors(this.settings.hideEmptyLines);
    });
  }
  onunload() {
    console.log("Unloading Regex Line Filter plugin");
    this.removeCss();
    this.app.workspace.iterateCodeMirrors((cm) => {
      try {
        const currentFilterState = cm.state.field(filterStateField, false);
        if (currentFilterState == null ? void 0 : currentFilterState.enabled) {
          cm.dispatch({ effects: toggleFilterEffect.of(false) });
        }
      } catch (e) {
      }
    });
  }
  // Load settings, ensuring regexHistory exists and is trimmed
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (!Array.isArray(this.settings.regexHistory)) {
      this.settings.regexHistory = [];
    }
    this.settings.regexHistory = this.settings.regexHistory.slice(0, REGEX_HISTORY_LIMIT);
  }
  // Save settings
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Update regex string history
  updateRegexHistory(newRegexString) {
    const filteredHistory = this.settings.regexHistory.filter((r) => r !== newRegexString);
    const updatedHistory = [newRegexString, ...filteredHistory];
    this.settings.regexHistory = updatedHistory.slice(0, REGEX_HISTORY_LIMIT);
    this.saveSettings();
  }
  dispatchSettingToEditors(newValue) {
    this.app.workspace.iterateCodeMirrors((cm) => {
      try {
        if (cm.state.field(filterStateField, false) !== void 0) {
          cm.dispatch({ effects: setHideEmptyLinesEffect.of(newValue) });
        }
      } catch (e) {
        console.warn("Regex Line Filter: Error dispatching setting", e);
      }
    });
  }
  addCss() {
    if (document.getElementById("regex-filter-styles"))
      return;
    const css = `.regex-filter-hidden-line { display: none !important; }`;
    this.cssStyleEl = document.createElement("style");
    this.cssStyleEl.id = "regex-line-filter-styles";
    this.cssStyleEl.textContent = css;
    document.head.appendChild(this.cssStyleEl);
  }
  removeCss() {
    if (this.cssStyleEl) {
      this.cssStyleEl.remove();
      this.cssStyleEl = null;
    }
    const existingStyle = document.getElementById("regex-filter-styles");
    if (existingStyle) {
      existingStyle.remove();
    }
  }
  toggleFilter(editor, view) {
    const cm = editor.cm;
    if (!cm || !(cm instanceof import_view.EditorView)) {
      new import_obsidian.Notice("Regex filter only works in Live Preview or Source Mode.");
      return;
    }
    const currentFilterState = cm.state.field(filterStateField, false);
    if (currentFilterState === void 0) {
      new import_obsidian.Notice("Filter not ready. Please try toggling again.");
      return;
    }
    if (currentFilterState.enabled) {
      cm.dispatch({ effects: toggleFilterEffect.of(false) });
      new import_obsidian.Notice("Regex filter disabled.");
    } else {
      this.promptForRegex(cm);
    }
  }
  // promptForRegex uses history for pre-fill and passes it to Modal
  promptForRegex(cm) {
    var _a, _b;
    const prefillValue = (_b = (_a = this.lastRegexStr) != null ? _a : this.settings.regexHistory[0]) != null ? _b : "";
    new RegexInputModal(this.app, prefillValue, this.settings.regexHistory, (result) => {
      if (result) {
        try {
          const regex = new RegExp(result, "u");
          this.lastRegexStr = result;
          this.updateRegexHistory(result);
          cm.dispatch({
            effects: [setRegexEffect.of(regex)]
          });
          new import_obsidian.Notice(`Regex filter enabled: /${result}/u`);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          new import_obsidian.Notice(`Invalid Regex: ${errorMessage}`);
          console.error("Regex Compile Error:", e);
          try {
            cm.dispatch({ effects: toggleFilterEffect.of(false) });
          } catch (e2) {
          }
        }
      } else {
        new import_obsidian.Notice("Regex filter cancelled.");
        try {
          cm.dispatch({ effects: toggleFilterEffect.of(false) });
        } catch (e) {
        }
      }
    }).open();
  }
};
var RegexLineFilterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Regex Line Filter Settings" });
    new import_obsidian.Setting(containerEl).setName("Hide empty lines").setDesc("When the filter is active, also hide lines that contain only whitespace.").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideEmptyLines).onChange(async (value) => {
      this.plugin.settings.hideEmptyLines = value;
      await this.plugin.saveSettings();
      this.plugin.dispatchSettingToEditors(value);
    }));
  }
};
var RegexInputModal = class extends import_obsidian.Modal {
  // Reference to the actual input element
  constructor(app, initialValue, history, onSubmit) {
    super(app);
    this.textInputEl = null;
    this.initialValue = initialValue;
    this.history = history;
    this.onSubmit = onSubmit;
    this.result = initialValue;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Enter Regex Filter" });
    this.inputComponent = new import_obsidian.Setting(contentEl).setName("Regular Expression (supports emoji):").addText((text) => {
      this.textInputEl = text.inputEl;
      text.setValue(this.initialValue).setPlaceholder("e.g., ^\\s*- \\[ \\].*\u{1F4A1}").onChange((value) => {
        this.result = value;
      });
      text.inputEl.focus();
      text.inputEl.select();
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey) {
          e.preventDefault();
          this.submit();
        }
      });
    });
    this.inputComponent.controlEl.addClass("regex-filter-input-control");
    if (this.history && this.history.length > 0) {
      const historyEl = contentEl.createDiv({ cls: "regex-filter-history-container" });
      historyEl.createSpan({ text: "History:", cls: "regex-filter-history-label" });
      this.history.forEach((histEntry) => {
        const btn = historyEl.createEl("button", {
          text: `/${histEntry}/`,
          // Display the regex string nicely
          cls: "regex-filter-history-item",
          attr: { title: histEntry }
          // Show full regex on hover if needed
        });
        btn.addEventListener("click", () => {
          if (this.textInputEl) {
            this.textInputEl.value = histEntry;
            this.result = histEntry;
            this.textInputEl.focus();
          }
        });
      });
    }
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Apply Filter").setCta().onClick(() => {
      this.submit();
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
      this.onSubmit(null);
    }));
  }
  submit() {
    if (this.result && this.result.trim().length > 0) {
      this.close();
      this.onSubmit(this.result);
    } else if (this.result === "") {
      new import_obsidian.Notice("Regex cannot be empty. Filter cancelled.");
      this.close();
      this.onSubmit(null);
    } else {
      new import_obsidian.Notice("Please enter a regular expression.");
    }
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBlZGl0b3JJbmZvRmllbGQsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFN0YXRlRmllbGQsIFN0YXRlRWZmZWN0LCBFeHRlbnNpb24sIFJhbmdlU2V0QnVpbGRlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIEVkaXRvclZpZXcsIFZpZXdQbHVnaW4sIFZpZXdVcGRhdGUsIFdpZGdldFR5cGUgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcblxuLy8gLS0tIENvbnN0YW50cyAtLS1cbmNvbnN0IFJFR0VYX0hJU1RPUllfTElNSVQgPSA1OyAvLyBNYXggbnVtYmVyIG9mIHJlZ2V4IHN0cmluZ3MgdG8gc3RvcmVcblxuLy8gLS0tIFNldHRpbmdzIC0tLVxuaW50ZXJmYWNlIFJlZ2V4TGluZUZpbHRlclNldHRpbmdzIHtcbiAgICBoaWRlRW1wdHlMaW5lczogYm9vbGVhbjtcbiAgICByZWdleEhpc3Rvcnk6IHN0cmluZ1tdOyAvLyBTdG9yZXMgcHJldmlvdXNseSB1c2VkIHJlZ2V4IHN0cmluZ3Ncbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogUmVnZXhMaW5lRmlsdGVyU2V0dGluZ3MgPSB7XG4gICAgaGlkZUVtcHR5TGluZXM6IHRydWUsXG4gICAgcmVnZXhIaXN0b3J5OiBbXSwgLy8gSW5pdGlhbGl6ZSBlbXB0eSBoaXN0b3J5IGZvciByZWdleCBzdHJpbmdzXG59XG5cbi8vIC0tLSBTdGF0ZSAmIEVmZmVjdHMgLS0tXG5pbnRlcmZhY2UgRmlsdGVyU3RhdGUge1xuICAgIHJlZ2V4OiBSZWdFeHAgfCBudWxsO1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgaGlkZUVtcHR5TGluZXM6IGJvb2xlYW47XG59XG5cbmNvbnN0IHNldFJlZ2V4RWZmZWN0ID0gU3RhdGVFZmZlY3QuZGVmaW5lPFJlZ0V4cCB8IG51bGw+KCk7XG5jb25zdCB0b2dnbGVGaWx0ZXJFZmZlY3QgPSBTdGF0ZUVmZmVjdC5kZWZpbmU8Ym9vbGVhbj4oKTtcbmNvbnN0IHNldEhpZGVFbXB0eUxpbmVzRWZmZWN0ID0gU3RhdGVFZmZlY3QuZGVmaW5lPGJvb2xlYW4+KCk7XG5cbi8vIC0tLSBWaWV3UGx1Z2luIGRlZmluaXRpb24gLS0tXG5jb25zdCBmaWx0ZXJWaWV3UGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoXG4gICAgY2xhc3Mge1xuICAgICAgICBkZWNvcmF0aW9uczogRGVjb3JhdGlvblNldDtcbiAgICAgICAgY29uc3RydWN0b3IodmlldzogRWRpdG9yVmlldykgeyB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY29yYXRpb25zKHZpZXcpOyB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IHVwZGF0ZS5zdGF0ZS5maWVsZChmaWx0ZXJTdGF0ZUZpZWxkKSAhPT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZmlsdGVyU3RhdGVGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvcmF0aW9ucyh1cGRhdGUudmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCBkZWNvcmF0aW9ucyAtIEl0ZXJhdGVzIEFMTCBsaW5lcyBhbmQgaW5jbHVkZXMgdHlwZW9mIGNoZWNrXG4gICAgICAgIGJ1aWxkRGVjb3JhdGlvbnModmlldzogRWRpdG9yVmlldyk6IERlY29yYXRpb25TZXQge1xuICAgICAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXI8RGVjb3JhdGlvbj4oKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVnZXgsIGVuYWJsZWQsIGhpZGVFbXB0eUxpbmVzIH0gPSB2aWV3LnN0YXRlLmZpZWxkKGZpbHRlclN0YXRlRmllbGQpO1xuXG4gICAgICAgICAgICBpZiAoIWVuYWJsZWQgfHwgIXJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdXNpbmcgbGluZSBudW1iZXJzIHRvIGVuc3VyZSBhbGwgbGluZXMgKGluY2x1ZGluZyBmb2xkZWQpIGFyZSBjaGVja2VkXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZG9jLmxpbmVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGRvYy5saW5lKGkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lVGV4dCA9IGxpbmU/LnRleHQ7IC8vIFNhZmVseSBhY2Nlc3MgdGV4dFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmVuc2l2ZSBjaGVjayBmb3IgdmFsaWQgc3RyaW5nIHRleHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsaW5lVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUmVnZXggTGluZSBGaWx0ZXI6IFNraXBwaW5nIGxpbmUgJHtpfSBkdWUgdG8gbm9uLXN0cmluZyB0ZXh0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gbGluZVRleHQudHJpbSgpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEhpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoZXNSZWdleCA9IHJlZ2V4LnRlc3QobGluZVRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlc1JlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRIaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGlkZUVtcHR5TGluZXMgJiYgaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkSGlkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSGlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQobGluZS5mcm9tLCBsaW5lLmZyb20sIERlY29yYXRpb24ubGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBjbGFzczogJ3JlZ2V4LWZpbHRlci1oaWRkZW4tbGluZScgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZWdleCBMaW5lIEZpbHRlcjogRXJyb3IgZHVyaW5nIGRlY29yYXRpb24gYnVpbGQ6XCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6ICh2KSA9PiB2LmRlY29yYXRpb25zLFxuICAgIH1cbik7XG4vLyAtLS0gRW5kIG9mIFZpZXdQbHVnaW4gZGVmaW5pdGlvbiAtLS1cblxuXG4vLyAtLS0gU3RhdGVGaWVsZCBkZWZpbml0aW9uIC0tLVxuY29uc3QgZmlsdGVyU3RhdGVGaWVsZCA9IFN0YXRlRmllbGQuZGVmaW5lPEZpbHRlclN0YXRlPih7XG4gICAgY3JlYXRlKHN0YXRlKTogRmlsdGVyU3RhdGUge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgIHJlZ2V4OiBudWxsLFxuICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgIGhpZGVFbXB0eUxpbmVzOiBERUZBVUxUX1NFVFRJTkdTLmhpZGVFbXB0eUxpbmVzLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cik6IEZpbHRlclN0YXRlIHtcbiAgICAgICAgbGV0IG5ld1ZhbHVlOiBGaWx0ZXJTdGF0ZSA9IHsgLi4udmFsdWUgfTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0UmVnZXhFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUucmVnZXggPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUuZW5hYmxlZCA9ICEhZWZmZWN0LnZhbHVlOyAvLyBFbmFibGUgaWYgcmVnZXggaXMgc2V0LCBkaXNhYmxlIGlmIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXModG9nZ2xlRmlsdGVyRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlLmVuYWJsZWQgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFlZmZlY3QudmFsdWUpIHsgLy8gRGlzYWJsaW5nXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFuZXdWYWx1ZS5yZWdleCkgeyAvLyBUcnlpbmcgdG8gZW5hYmxlIHdpdGhvdXQgcmVnZXhcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBdHRlbXB0ZWQgdG8gZW5hYmxlIGZpbHRlciB3aXRob3V0IGEgcmVnZXguXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0SGlkZUVtcHR5TGluZXNFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUuaGlkZUVtcHR5TGluZXMgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH1cbn0pO1xuLy8gLS0tIEVuZCBvZiBTdGF0ZSBGaWVsZCBEZWZpbml0aW9uIC0tLVxuXG5cbi8vIC0tLSBQbHVnaW4gQ2xhc3MgZGVmaW5pdGlvbiAtLS1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ2V4TGluZUZpbHRlclBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgc2V0dGluZ3M6IFJlZ2V4TGluZUZpbHRlclNldHRpbmdzO1xuICAgIGxhc3RSZWdleFN0cjogc3RyaW5nIHwgbnVsbCA9IG51bGw7IC8vIFN0b3JlcyB0aGUgbW9zdCByZWNlbnQgc3VjY2Vzc2Z1bCByZWdleCBzdHJpbmcgZm9yIHByZS1maWxsaW5nXG4gICAgY3NzU3R5bGVFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgUmVnZXggTGluZSBGaWx0ZXIgcGx1Z2luJyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAndG9nZ2xlLXJlZ2V4LWZpbHRlcicsXG4gICAgICAgICAgICBuYW1lOiAnVG9nZ2xlIFJlZ2V4IExpbmUgRmlsdGVyJyxcbiAgICAgICAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlRmlsdGVyKGVkaXRvciwgdmlldyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFJlZ2V4TGluZUZpbHRlclNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihbZmlsdGVyU3RhdGVGaWVsZCwgZmlsdGVyVmlld1BsdWdpbl0pO1xuICAgICAgICB0aGlzLmFkZENzcygpO1xuXG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTZXR0aW5nVG9FZGl0b3JzKHRoaXMuc2V0dGluZ3MuaGlkZUVtcHR5TGluZXMpO1xuICAgICAgICB9KTtcbiAgICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVbmxvYWRpbmcgUmVnZXggTGluZSBGaWx0ZXIgcGx1Z2luJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ3NzKCk7XG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5pdGVyYXRlQ29kZU1pcnJvcnMoY20gPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmlsdGVyU3RhdGUgPSBjbS5zdGF0ZS5maWVsZChmaWx0ZXJTdGF0ZUZpZWxkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWx0ZXJTdGF0ZT8uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjbS5kaXNwYXRjaCh7IGVmZmVjdHM6IHRvZ2dsZUZpbHRlckVmZmVjdC5vZihmYWxzZSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgICAgICB9KTtcbiAgICAgfVxuXG4gICAgLy8gTG9hZCBzZXR0aW5ncywgZW5zdXJpbmcgcmVnZXhIaXN0b3J5IGV4aXN0cyBhbmQgaXMgdHJpbW1lZFxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnNldHRpbmdzLnJlZ2V4SGlzdG9yeSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVnZXhIaXN0b3J5ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yZWdleEhpc3RvcnkgPSB0aGlzLnNldHRpbmdzLnJlZ2V4SGlzdG9yeS5zbGljZSgwLCBSRUdFWF9ISVNUT1JZX0xJTUlUKTtcbiAgICB9XG5cbiAgICAvLyBTYXZlIHNldHRpbmdzXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSByZWdleCBzdHJpbmcgaGlzdG9yeVxuICAgIHVwZGF0ZVJlZ2V4SGlzdG9yeShuZXdSZWdleFN0cmluZzogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkSGlzdG9yeSA9IHRoaXMuc2V0dGluZ3MucmVnZXhIaXN0b3J5LmZpbHRlcihyID0+IHIgIT09IG5ld1JlZ2V4U3RyaW5nKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEhpc3RvcnkgPSBbbmV3UmVnZXhTdHJpbmcsIC4uLmZpbHRlcmVkSGlzdG9yeV07XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucmVnZXhIaXN0b3J5ID0gdXBkYXRlZEhpc3Rvcnkuc2xpY2UoMCwgUkVHRVhfSElTVE9SWV9MSU1JVCk7XG4gICAgICAgIHRoaXMuc2F2ZVNldHRpbmdzKCk7IC8vIFBlcnNpc3QgaGlzdG9yeVxuICAgIH1cblxuXG4gICAgZGlzcGF0Y2hTZXR0aW5nVG9FZGl0b3JzKG5ld1ZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5pdGVyYXRlQ29kZU1pcnJvcnMoY20gPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY20uc3RhdGUuZmllbGQoZmlsdGVyU3RhdGVGaWVsZCwgZmFsc2UpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY20uZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRIaWRlRW1wdHlMaW5lc0VmZmVjdC5vZihuZXdWYWx1ZSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBjb25zb2xlLndhcm4oXCJSZWdleCBMaW5lIEZpbHRlcjogRXJyb3IgZGlzcGF0Y2hpbmcgc2V0dGluZ1wiLCBlKTsgfVxuICAgICAgICB9KTtcbiAgICAgfVxuXG4gICAgYWRkQ3NzKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlZ2V4LWZpbHRlci1zdHlsZXMnKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBjc3MgPSBgLnJlZ2V4LWZpbHRlci1oaWRkZW4tbGluZSB7IGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfWA7XG4gICAgICAgIHRoaXMuY3NzU3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHRoaXMuY3NzU3R5bGVFbC5pZCA9ICdyZWdleC1saW5lLWZpbHRlci1zdHlsZXMnO1xuICAgICAgICB0aGlzLmNzc1N0eWxlRWwudGV4dENvbnRlbnQgPSBjc3M7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5jc3NTdHlsZUVsKTtcbiAgICAgfVxuXG4gICAgcmVtb3ZlQ3NzKCkge1xuICAgICAgICAgaWYgKHRoaXMuY3NzU3R5bGVFbCkgeyB0aGlzLmNzc1N0eWxlRWwucmVtb3ZlKCk7IHRoaXMuY3NzU3R5bGVFbCA9IG51bGw7IH1cbiAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3R5bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVnZXgtZmlsdGVyLXN0eWxlcycpO1xuICAgICAgICAgaWYgKGV4aXN0aW5nU3R5bGUpIHsgZXhpc3RpbmdTdHlsZS5yZW1vdmUoKTsgfVxuICAgIH1cblxuICAgIHRvZ2dsZUZpbHRlcihlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSB7XG4gICAgICAgIGNvbnN0IGNtID0gKGVkaXRvciBhcyBhbnkpLmNtIGFzIEVkaXRvclZpZXc7XG4gICAgICAgIGlmICghY20gfHwgIShjbSBpbnN0YW5jZW9mIEVkaXRvclZpZXcpKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiUmVnZXggZmlsdGVyIG9ubHkgd29ya3MgaW4gTGl2ZSBQcmV2aWV3IG9yIFNvdXJjZSBNb2RlLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50RmlsdGVyU3RhdGUgPSBjbS5zdGF0ZS5maWVsZChmaWx0ZXJTdGF0ZUZpZWxkLCBmYWxzZSk7XG4gICAgICAgIGlmKGN1cnJlbnRGaWx0ZXJTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRmlsdGVyIG5vdCByZWFkeS4gUGxlYXNlIHRyeSB0b2dnbGluZyBhZ2Fpbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEZpbHRlclN0YXRlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNtLmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlRmlsdGVyRWZmZWN0Lm9mKGZhbHNlKSB9KTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1JlZ2V4IGZpbHRlciBkaXNhYmxlZC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFByb21wdCBmb3IgcmVnZXgsIHBhc3NpbmcgQ00gdmlldyBmb3IgZGlzcGF0Y2hpbmcgbGF0ZXJcbiAgICAgICAgICAgIHRoaXMucHJvbXB0Rm9yUmVnZXgoY20pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJvbXB0Rm9yUmVnZXggdXNlcyBoaXN0b3J5IGZvciBwcmUtZmlsbCBhbmQgcGFzc2VzIGl0IHRvIE1vZGFsXG4gICAgcHJvbXB0Rm9yUmVnZXgoY206IEVkaXRvclZpZXcpIHtcbiAgICAgICAgY29uc3QgcHJlZmlsbFZhbHVlID0gdGhpcy5sYXN0UmVnZXhTdHIgPz8gdGhpcy5zZXR0aW5ncy5yZWdleEhpc3RvcnlbMF0gPz8gXCJcIjtcblxuICAgICAgICBuZXcgUmVnZXhJbnB1dE1vZGFsKHRoaXMuYXBwLCBwcmVmaWxsVmFsdWUsIHRoaXMuc2V0dGluZ3MucmVnZXhIaXN0b3J5LCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7IC8vIHJlc3VsdCBpcyB0aGUgcmVnZXggc3RyaW5nIGZyb20gdGhlIG1vZGFsXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlc3VsdCwgJ3UnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgaGlzdG9yeSBhbmQgbGFzdCB1c2VkIHN0cmluZyAqYmVmb3JlKiBkaXNwYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZWdleFN0ciA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZWdleEhpc3RvcnkocmVzdWx0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXNwYXRjaCBvbmx5IHRoZSBlZmZlY3QgdG8gc2V0IHRoZSByZWdleFxuICAgICAgICAgICAgICAgICAgICBjbS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBbIHNldFJlZ2V4RWZmZWN0Lm9mKHJlZ2V4KSBdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBSZWdleCBmaWx0ZXIgZW5hYmxlZDogLyR7cmVzdWx0fS91YCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAoZSBpbnN0YW5jZW9mIEVycm9yKSA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgSW52YWxpZCBSZWdleDogJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZWdleCBDb21waWxlIEVycm9yOlwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHsgY20uZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVGaWx0ZXJFZmZlY3Qub2YoZmFsc2UpIH0pOyB9IGNhdGNoKGUpIHsgLyogSWdub3JlICovIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdSZWdleCBmaWx0ZXIgY2FuY2VsbGVkLicpO1xuICAgICAgICAgICAgICAgICB0cnkgeyBjbS5kaXNwYXRjaCh7IGVmZmVjdHM6IHRvZ2dsZUZpbHRlckVmZmVjdC5vZihmYWxzZSkgfSk7IH0gY2F0Y2goZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS5vcGVuKCk7XG4gICAgfVxufSAvLyBFbmQgb2YgUGx1Z2luIENsYXNzXG5cbi8vIC0tLSBTZXR0aW5ncyBUYWIgQ2xhc3MgLS0tXG5jbGFzcyBSZWdleExpbmVGaWx0ZXJTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG5cdHBsdWdpbjogUmVnZXhMaW5lRmlsdGVyUGx1Z2luO1xuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBSZWdleExpbmVGaWx0ZXJQbHVnaW4pIHsgc3VwZXIoYXBwLCBwbHVnaW4pOyB0aGlzLnBsdWdpbiA9IHBsdWdpbjsgfVxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywge3RleHQ6ICdSZWdleCBMaW5lIEZpbHRlciBTZXR0aW5ncyd9KTtcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdIaWRlIGVtcHR5IGxpbmVzJylcblx0XHRcdC5zZXREZXNjKCdXaGVuIHRoZSBmaWx0ZXIgaXMgYWN0aXZlLCBhbHNvIGhpZGUgbGluZXMgdGhhdCBjb250YWluIG9ubHkgd2hpdGVzcGFjZS4nKVxuXHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5oaWRlRW1wdHlMaW5lcylcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmhpZGVFbXB0eUxpbmVzID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmRpc3BhdGNoU2V0dGluZ1RvRWRpdG9ycyh2YWx1ZSk7XG5cdFx0XHRcdH0pKTtcbiAgICAgICAgLy8gWW91IGNvdWxkIGFkZCBhIFwiQ2xlYXIgSGlzdG9yeVwiIGJ1dHRvbiBoZXJlIGlmIGRlc2lyZWQgbGF0ZXJcblx0fVxufVxuXG4vLyAtLS0gTW9kYWwgQ2xhc3MgZGVmaW5pdGlvbiAoSW5jbHVkZXMgSGlzdG9yeSBEaXNwbGF5KSAtLS1cbmNsYXNzIFJlZ2V4SW5wdXRNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICByZXN1bHQ6IHN0cmluZztcbiAgICBvblN1Ym1pdDogKHJlc3VsdDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgICBpbml0aWFsVmFsdWU6IHN0cmluZztcbiAgICBoaXN0b3J5OiBzdHJpbmdbXTsgLy8gU3RvcmVzIHRoZSByZWdleCBzdHJpbmdzXG4gICAgaW5wdXRDb21wb25lbnQ6IFNldHRpbmc7XG4gICAgdGV4dElucHV0RWw6IEhUTUxJbnB1dEVsZW1lbnQgfCBudWxsID0gbnVsbDsgLy8gUmVmZXJlbmNlIHRvIHRoZSBhY3R1YWwgaW5wdXQgZWxlbWVudFxuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGluaXRpYWxWYWx1ZTogc3RyaW5nLCBoaXN0b3J5OiBzdHJpbmdbXSwgb25TdWJtaXQ6IChyZXN1bHQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdFbnRlciBSZWdleCBGaWx0ZXInIH0pO1xuXG4gICAgICAgIHRoaXMuaW5wdXRDb21wb25lbnQgPSBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUmVndWxhciBFeHByZXNzaW9uIChzdXBwb3J0cyBlbW9qaSk6JylcbiAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0SW5wdXRFbCA9IHRleHQuaW5wdXRFbDsgLy8gU3RvcmUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLmluaXRpYWxWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuLCBeXFxcXHMqLSBcXFxcWyBcXFxcXS4qXHVEODNEXHVEQ0ExJylcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKCh2YWx1ZSkgPT4geyB0aGlzLnJlc3VsdCA9IHZhbHVlOyB9KTtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiYgIWUuc2hpZnRLZXkgJiYgIWUuY3RybEtleSAmJiAhZS5tZXRhS2V5ICYmICFlLmFsdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5wdXRDb21wb25lbnQuY29udHJvbEVsLmFkZENsYXNzKCdyZWdleC1maWx0ZXItaW5wdXQtY29udHJvbCcpO1xuXG4gICAgICAgIC8vIC0tLSBBZGQgUmVnZXggU3RyaW5nIEhpc3RvcnkgU2VjdGlvbiAtLS1cbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaGlzdG9yeUVsID0gY29udGVudEVsLmNyZWF0ZURpdih7IGNsczogJ3JlZ2V4LWZpbHRlci1oaXN0b3J5LWNvbnRhaW5lcicgfSk7XG4gICAgICAgICAgICBoaXN0b3J5RWwuY3JlYXRlU3Bhbih7IHRleHQ6ICdIaXN0b3J5OicsIGNsczogJ3JlZ2V4LWZpbHRlci1oaXN0b3J5LWxhYmVsJyB9KTtcblxuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LmZvckVhY2goaGlzdEVudHJ5ID0+IHsgLy8gaGlzdEVudHJ5IGlzIGEgcmVnZXggc3RyaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgYnRuID0gaGlzdG9yeUVsLmNyZWF0ZUVsKCdidXR0b24nLCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGAvJHtoaXN0RW50cnl9L2AsIC8vIERpc3BsYXkgdGhlIHJlZ2V4IHN0cmluZyBuaWNlbHlcbiAgICAgICAgICAgICAgICAgICAgY2xzOiAncmVnZXgtZmlsdGVyLWhpc3RvcnktaXRlbScsXG4gICAgICAgICAgICAgICAgICAgIGF0dHI6IHsgdGl0bGU6IGhpc3RFbnRyeSB9IC8vIFNob3cgZnVsbCByZWdleCBvbiBob3ZlciBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRleHRJbnB1dEVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRJbnB1dEVsLnZhbHVlID0gaGlzdEVudHJ5OyAvLyBVcGRhdGUgaW5wdXQgZmllbGQgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBoaXN0RW50cnk7IC8vIFVwZGF0ZSBpbnRlcm5hbCByZXN1bHQgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dElucHV0RWwuZm9jdXMoKTsgLy8gS2VlcCBmb2N1cyBvbiBpbnB1dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0gRW5kIEhpc3RvcnkgU2VjdGlvbiAtLS1cblxuICAgICAgICAvLyBBY3Rpb24gYnV0dG9uc1xuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKChidG4pID0+IGJ0bi5zZXRCdXR0b25UZXh0KCdBcHBseSBGaWx0ZXInKS5zZXRDdGEoKS5vbkNsaWNrKCgpID0+IHsgdGhpcy5zdWJtaXQoKTsgfSkpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKChidG4pID0+IGJ0bi5zZXRCdXR0b25UZXh0KCdDYW5jZWwnKS5vbkNsaWNrKCgpID0+IHsgdGhpcy5jbG9zZSgpOyB0aGlzLm9uU3VibWl0KG51bGwpOyB9KSk7XG4gICAgfVxuXG4gICAgc3VibWl0KCkge1xuICAgICAgICAvLyBVc2UgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcy5yZXN1bHQgKHJlZmxlY3RzIHR5cGVkIG9yIGNsaWNrZWQgaGlzdG9yeSlcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0ICYmIHRoaXMucmVzdWx0LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgIHRoaXMub25TdWJtaXQodGhpcy5yZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVzdWx0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgbmV3IE5vdGljZShcIlJlZ2V4IGNhbm5vdCBiZSBlbXB0eS4gRmlsdGVyIGNhbmNlbGxlZC5cIik7XG4gICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgIHRoaXMub25TdWJtaXQobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgbmV3IE5vdGljZShcIlBsZWFzZSBlbnRlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuICAgIH1cbn1cbi8vIC0tLSBFbmQgb2YgTW9kYWwgQ2xhc3MgZGVmaW5pdGlvbiAtLS0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQW9IO0FBQ3BILG1CQUFpRjtBQUNqRixrQkFBMEY7QUFHMUYsSUFBTSxzQkFBc0I7QUFRNUIsSUFBTSxtQkFBNEM7QUFBQSxFQUM5QyxnQkFBZ0I7QUFBQSxFQUNoQixjQUFjLENBQUM7QUFBQTtBQUNuQjtBQVNBLElBQU0saUJBQWlCLHlCQUFZLE9BQXNCO0FBQ3pELElBQU0scUJBQXFCLHlCQUFZLE9BQWdCO0FBQ3ZELElBQU0sMEJBQTBCLHlCQUFZLE9BQWdCO0FBRzVELElBQU0sbUJBQW1CLHVCQUFXO0FBQUEsRUFDaEMsTUFBTTtBQUFBLElBRUYsWUFBWSxNQUFrQjtBQUFFLFdBQUssY0FBYyxLQUFLLGlCQUFpQixJQUFJO0FBQUEsSUFBRztBQUFBLElBQ2hGLE9BQU8sUUFBb0I7QUFDdkIsVUFBSSxPQUFPLGNBQWMsT0FBTyxtQkFBbUIsT0FBTyxNQUFNLE1BQU0sZ0JBQWdCLE1BQU0sT0FBTyxXQUFXLE1BQU0sZ0JBQWdCLEdBQUc7QUFDbEksYUFBSyxjQUFjLEtBQUssaUJBQWlCLE9BQU8sSUFBSTtBQUFBLE1BQ3pEO0FBQUEsSUFDSjtBQUFBO0FBQUEsSUFHQSxpQkFBaUIsTUFBaUM7QUFDOUMsWUFBTSxVQUFVLElBQUksNkJBQTRCO0FBQ2hELFlBQU0sRUFBRSxPQUFPLFNBQVMsZUFBZSxJQUFJLEtBQUssTUFBTSxNQUFNLGdCQUFnQjtBQUU1RSxVQUFJLENBQUMsV0FBVyxDQUFDLE9BQU87QUFDcEIsZUFBTyxRQUFRLE9BQU87QUFBQSxNQUMxQjtBQUVBLFlBQU0sTUFBTSxLQUFL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QSxNQUNKLENBQUM7QUFBQSxJQUNMLENBQUM7QUFDTCxTQUFLLGVBQWUsVUFBVSxTQUFTLDRCQUE0QjtBQUduRSxRQUFJLEtBQUssV0FBVyxLQUFLLFFBQVEsU0FBUyxHQUFHO0FBQ3pDLFlBQU0sWUFBWSxVQUFVLFVBQVUsRUFBRSxLQUFLLGlDQUFpQyxDQUFDO0FBQy9FLGdCQUFVLFdBQVcsRUFBRSxNQUFNLFlBQVksS0FBSyw2QkFBNkIsQ0FBQztBQUU1RSxXQUFLLFFBQVEsUUFBUSxlQUFhO0FBQzlCLGNBQU0sTUFBTSxVQUFVLFNBQVMsVUFBVTtBQUFBLFVBQ3JDLE1BQU0sSUFBSTtBQUFBO0FBQUEsVUFDVixLQUFLO0FBQUEsVUFDTCxNQUFNLEVBQUUsT0FBTyxVQUFVO0FBQUE7QUFBQSxRQUM3QixDQUFDO0FBQ0QsWUFBSSxpQkFBaUIsU0FBUyxNQUFNO0FBQ2hDLGNBQUksS0FBSyxhQUFhO0FBQ2xCLGlCQUFLLFlBQVksUUFBUTtBQUN6QixpQkFBSyxTQUFTO0FBQ2QsaUJBQUssWUFBWSxNQUFNO0FBQUEsVUFDM0I7QUFBQSxRQUNKLENBQUM7QUFBQSxNQUNMLENBQUM7QUFBQSxJQUNMO0FBSUEsUUFBSSx3QkFBUSxTQUFTLEVBQ2hCLFVBQVUsQ0FBQyxRQUFRLElBQUksY0FBYyxjQUFjLEVBQUUsT0FBTyxFQUFFLFFBQVEsTUFBTTtBQUFFLFdBQUssT0FBTztBQUFBLElBQUcsQ0FBQyxDQUFDLEVBQy9GLFVBQVUsQ0FBQyxRQUFRLElBQUksY0FBYyxRQUFRLEVBQUUsUUFBUSxNQUFNO0FBQUUsV0FBSyxNQUFNO0FBQUcsV0FBSyxTQUFTLElBQUk7QUFBQSxJQUFHLENBQUMsQ0FBQztBQUFBLEVBQzdHO0FBQUEsRUFFQSxTQUFTO0FBRUwsUUFBSSxLQUFLLFVBQVUsS0FBSyxPQUFPLEtBQUssRUFBRSxTQUFTLEdBQUc7QUFDN0MsV0FBSyxNQUFNO0FBQ1gsV0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzlCLFdBQVcsS0FBSyxXQUFXLElBQUk7QUFDMUIsVUFBSSx1QkFBTywwQ0FBMEM7QUFDckQsV0FBSyxNQUFNO0FBQ1gsV0FBSyxTQUFTLElBQUk7QUFBQSxJQUN2QixPQUFPO0FBQ0YsVUFBSSx1QkFBTyxvQ0FBb0M7QUFBQSxJQUNwRDtBQUFBLEVBQ0o7QUFBQSxFQUVBLFVBQVU7QUFDTixRQUFJLEVBQUUsVUFBVSxJQUFJO0FBQ3BCLGNBQVUsTUFBTTtBQUFBLEVBQ3BCO0FBQ0o7IiwKICAibmFtZXMiOiBbImUiXQp9Cg==
